var t=Object.defineProperty,e=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,d=(e,n,o)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[n]=o,s=(t,s)=>{for(var l in s||(s={}))n.call(s,l)&&d(t,l,s[l]);if(e)for(var l of e(s))o.call(s,l)&&d(t,l,s[l]);return t};import{H as l,o as a,C as c,D as r,v as i,P as u,at as p,_ as g,as as m}from"./vue.69b6befa.js";import{_ as h,H as f}from"./index.f86c4400.js";import{H as x}from"./hongluan-icons.f9afdbe4.js";import"./hongluan.17b69477.js";import"./highlight.5ad4a187.js";const B={name:"component-doc",components:{"hl-demo0":function(){const{createTextVNode:t,resolveComponent:e,withCtx:n,openBlock:o,createBlock:d}=p,l=t("点击打开 Message Box");const{defineComponent:a,ref:c}=p,{HlMessageBox:r,HlMessage:i}=f,u=a({setup:()=>({open:()=>{r.alert("这是一段内容","标题名称",{confirmButtonText:"确定",callback:t=>{i({type:"info",message:`action: ${t}`})}})}})});return s({render:function(t,s){const a=e("hl-button");return o(),d(a,{type:"link",onClick:t.open},{default:n((()=>[l])),_:1},8,["onClick"])}},u)}(),"hl-demo1":function(){const{createTextVNode:t,resolveComponent:e,withCtx:n,openBlock:o,createBlock:d}=p,l=t("点击打开 Message Box");const{defineComponent:a,ref:c}=p,{HlMessageBox:r,HlMessage:i}=f,u=a({setup:()=>({open:()=>{r.confirm("此操作将永久删除该文件, 是否继续?","提示",{confirmButtonText:"确定",confirmButtonType:"danger",cancelButtonText:"取消",type:"success"}).then((()=>{i({type:"success",message:"删除成功!"})})).catch((()=>{i({type:"info",message:"已取消删除"})}))}})});return s({render:function(t,s){const a=e("hl-button");return o(),d(a,{type:"link",onClick:t.open},{default:n((()=>[l])),_:1},8,["onClick"])}},u)}(),"hl-demo2":function(){const{createTextVNode:t,resolveComponent:e,withCtx:n,openBlock:o,createBlock:d}=p,l=t("点击打开 Message Box");const{defineComponent:a,ref:c,h:r,resolveComponent:i}=p,{HlMessageBox:u,HlMessage:g,HlIcon:m}=f,{Airplay:h}=x,B=a({setup:()=>({open:()=>{u({title:"消息",message:r("p",null,[r("span",null,"内容可以是 "),r("i",{style:"color: teal"},"VNode")]),icon:r(m,{size:"xl"},[r(h)]),showCancelButton:!0,confirmButtonText:"确定",cancelButtonText:"取消",beforeClose:(t,e,n)=>{"confirm"===t?(e.confirmButtonLoading=!0,e.confirmButtonText="执行中...",setTimeout((()=>{n(),setTimeout((()=>{e.confirmButtonLoading=!1}),300)}),3e3)):n()}}).then((t=>{g({type:"info",message:"action: "+t})}))}})});return s({render:function(t,s){const a=e("hl-button");return o(),d(a,{type:"link",onClick:t.open},{default:n((()=>[l])),_:1},8,["onClick"])}},B)}(),"hl-demo3":function(){const{createTextVNode:t,resolveComponent:e,withCtx:n,openBlock:o,createBlock:d}=p,l=t("点击打开 Message Box");const{defineComponent:a,ref:c,h:r}=p,{HlMessageBox:i}=f,u=a({setup:()=>({open:()=>{i.alert("<strong>这是 <i>HTML</i> 片段</strong>","HTML 片段",{dangerouslyUseHTMLString:!0})}})});return s({render:function(t,s){const a=e("hl-button");return o(),d(a,{type:"link",onClick:t.open},{default:n((()=>[l])),_:1},8,["onClick"])}},u)}(),"hl-demo4":function(){const{createTextVNode:t,resolveComponent:e,withCtx:n,openBlock:o,createBlock:d}=p,l=t("点击打开 Message Box");const{defineComponent:a,ref:c,h:r}=p,{HlMessageBox:i,HlMessage:u}=f,g=a({setup:()=>({open:()=>{i.confirm("检测到未保存的内容，是否在离开页面前保存修改？","确认信息",{distinguishCancelAndClose:!0,confirmButtonText:"保存",cancelButtonText:"放弃修改"}).then((()=>{u({type:"info",message:"保存修改"})})).catch((t=>{u({type:"info",message:"cancel"===t?"放弃保存并离开页面":"停留在当前页面"})}))}})});return s({render:function(t,s){const a=e("hl-button");return o(),d(a,{type:"link",onClick:t.open},{default:n((()=>[l])),_:1},8,["onClick"])}},g)}()}},M={class:"doc-main-content"},y={class:"doc-content"},C=r("h1",null,"MessageBox 弹框",-1),b=r("p",null,"模拟系统的消息提示框而实现的一套模态对话框组件，用于消息提示、确认消息和提交内容。",-1),H=r("div",{class:"md-tip"},[r("p",null,[g("从场景上说，MessageBox 的作用是美化系统自带的 "),r("code",null,"alert"),g("和"),r("code",null,"confirm"),g("，因此适合展示较为简单的内容。如果需要弹出较为复杂的内容，请使用 Dialog。")])],-1),T=r("h2",{id:"xiao-xi-ti-shi"},[r("a",{class:"header-anchor",href:"#xiao-xi-ti-shi"}),g(" 消息提示")],-1),k=r("p",null,"当用户进行操作时会被触发，该对话框中断用户操作，直到用户确认知晓后才可关闭。",-1),v=r("div",null,[r("p",null,[g("调用"),r("code",null,"$alert"),g("方法即可打开消息提示，它模拟了系统的 "),r("code",null,"alert"),g("，无法通过按下 ESC 或点击框外关闭。此例中接收了两个参数，"),r("code",null,"message"),g("和"),r("code",null,"title"),g("。值得一提的是，窗口被关闭后，它默认会返回一个"),r("code",null,"Promise"),g("对象便于进行后续操作的处理。若不确定浏览器是否支持"),r("code",null,"Promise"),g("，可自行引入第三方 polyfill 或像本例一样使用回调进行后续处理。")])],-1),w=r("pre",null,[r("code",{class:"html"},"<template>\n  <hl-button type=\"link\" @click=\"open\">点击打开 Message Box</hl-button>\n</template>\n\n<script>\nimport { defineComponent, ref } from 'vue'\nimport { HlMessageBox, HlMessage } from 'hongluan-ui'\nexport default defineComponent({\n  setup() {\n    const open = () => {\n      HlMessageBox.alert('这是一段内容', '标题名称', {\n        confirmButtonText: '确定',\n        callback: action => {\n          HlMessage({\n            type: 'info',\n            message: `action: ${action}`,\n          })\n        },\n      })\n    }\n    return {\n      open,\n    }\n  }\n})\n<\/script>\n")],-1),j=r("h2",{id:"que-ren-xiao-xi"},[r("a",{class:"header-anchor",href:"#que-ren-xiao-xi"}),g(" 确认消息")],-1),L=r("p",null,"提示用户确认其已经触发的动作，并询问是否进行此操作时会用到此对话框。",-1),S=r("div",null,[r("p",null,[g("调用"),r("code",null,"$confirm"),g("方法即可打开消息提示，它模拟了系统的 "),r("code",null,"confirm"),g("。Message Box 组件也拥有极高的定制性，我们可以传入"),r("code",null,"options"),g("作为第三个参数，它是一个字面量对象。"),r("code",null,"type"),g("字段用来显示头部 icon，可以为"),r("code",null,"success"),g("，"),r("code",null,"error"),g("，"),r("code",null,"info"),g("和"),r("code",null,"warning"),g("，除了以上自定义的名称，其它 type 值将被认为直接是 Icon 组件的名称，此时可以配合 iconProps 属性自定义 icon 样式。注意，第二个参数"),r("code",null,"title"),g("必须定义为"),r("code",null,"String"),g("类型，如果是"),r("code",null,"Object"),g("，会被理解为"),r("code",null,"options"),g("。在这里我们用了 Promise 来处理后续响应。")])],-1),$=r("pre",null,[r("code",{class:"html"},"<template>\n  <hl-button type=\"link\" @click=\"open\">点击打开 Message Box</hl-button>\n</template>\n\n<script>\nimport { defineComponent, ref } from 'vue'\nimport { HlMessageBox, HlMessage } from 'hongluan-ui'\nexport default defineComponent({\n  setup() {\n    const open = () =>{\n      HlMessageBox.confirm('此操作将永久删除该文件, 是否继续?', '提示', {\n        confirmButtonText: '确定',\n        confirmButtonType: 'danger',\n        cancelButtonText: '取消',\n        type: 'success'\n      })\n        .then(() => {\n          HlMessage({\n            type: 'success',\n            message: '删除成功!',\n          })\n        })\n        .catch(() => {\n          HlMessage({\n            type: 'info',\n            message: '已取消删除',\n          })\n        })\n      }\n    return {\n      open,\n    }\n  }\n})\n<\/script>\n")],-1),V=r("h2",{id:"zi-ding-yi"},[r("a",{class:"header-anchor",href:"#zi-ding-yi"}),g(" 自定义")],-1),N=r("p",null,"可自定义配置不同内容。",-1),_=r("div",null,[r("p",null,[g("以上三个方法都是对"),r("code",null,"$msgbox"),g("方法的再包装。本例直接调用"),r("code",null,"$msgbox"),g("方法，使用了"),r("code",null,"showCancelButton"),g("字段，用于显示取消按钮。另外可使用"),r("code",null,"cancelButtonClass"),g("为其添加自定义样式，使用"),r("code",null,"cancelButtonText"),g("来自定义按钮文本（Confirm 按钮也具有相同的字段，在文末的字段说明中有完整的字段列表）。此例还使用了"),r("code",null,"beforeClose"),g("属性，它的值是一个方法，会在 MessageBox 的实例关闭前被调用，同时暂停实例的关闭。它有三个参数："),r("code",null,"action"),g("、实例本身和"),r("code",null,"done"),g("方法。使用它能够在关闭前对实例进行一些操作，比如为确定按钮添加"),r("code",null,"loading"),g("状态等；此时若需要关闭实例，可以调用"),r("code",null,"done"),g("方法（若在"),r("code",null,"beforeClose"),g("中没有调用"),r("code",null,"done"),g("，则实例不会关闭）。")])],-1),P=r("pre",null,[r("code",{class:"html"},"<template>\n  <hl-button type=\"link\" @click=\"open\">点击打开 Message Box</hl-button>\n</template>\n\n<script>\nimport { defineComponent, ref, h, resolveComponent } from 'vue'\nimport { HlMessageBox, HlMessage, HlIcon } from 'hongluan-ui'\nimport { Airplay } from '@hongluan-ui/icons'\n\nexport default defineComponent({\n  setup() {\n    const open = () => {\n      HlMessageBox({\n        title: '消息',\n        message: h('p', null, [\n          h('span', null, '内容可以是 '),\n          h('i', { style: 'color: teal' }, 'VNode'),\n        ]),\n        icon: h(HlIcon, { size: 'xl' }, [h(Airplay)]),\n        showCancelButton: true,\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        beforeClose: (action, instance, done) => {\n          if (action === 'confirm') {\n            instance.confirmButtonLoading = true\n            instance.confirmButtonText = '执行中...'\n            setTimeout(() => {\n              done()\n              setTimeout(() => {\n                instance.confirmButtonLoading = false\n              }, 300)\n            }, 3000)\n          } else {\n            done()\n          }\n        },\n      }).then(action => {\n        HlMessage({\n          type: 'info',\n          message: 'action: ' + action,\n        })\n      })\n    }\n    return {\n      open,\n    }\n  }\n})\n<\/script>\n")],-1),O=m('<div class="md-tip"><p>弹出层的内容可以是 <code>VNode</code>，所以我们能把一些自定义组件传入其中。每次弹出层打开后，Vue 会对新老 <code>VNode</code> 节点进行比对，然后将根据比较结果进行最小单位地修改视图。这也许会造成弹出层内容区域的组件没有重新渲染，例如 <a href="https://github.com/ElemeFE/element/issues/8931">#8931</a>。当这类问题出现时，解决方案是给 <code>VNode</code> 加上一个不相同的 key，参考<a href="https://jsfiddle.net/zhiyang/ezmhq2ef/">这里</a>。</p></div><h2 id="shi-yong-html-pian-duan"><a class="header-anchor" href="#shi-yong-html-pian-duan"></a> 使用 HTML 片段</h2><p><code>message</code> 属性支持传入 HTML 片段。</p>',3),q=r("div",null,[r("p",null,[g("将"),r("code",null,"dangerouslyUseHTMLString"),g("属性设置为 true，"),r("code",null,"message"),g(" 就会被当作 HTML 片段处理。")])],-1),A=r("pre",null,[r("code",{class:"html"},"<template>\n  <hl-button type=\"link\" @click=\"open\">点击打开 Message Box</hl-button>\n</template>\n\n<script>\nimport { defineComponent, ref, h } from 'vue'\nimport { HlMessageBox } from 'hongluan-ui'\nexport default defineComponent({\n  setup() {\n    const open = () => {\n      HlMessageBox.alert('<strong>这是 <i>HTML</i> 片段</strong>', 'HTML 片段', {\n        dangerouslyUseHTMLString: true,\n      })\n    }\n    return {\n      open,\n    }\n  }\n})\n<\/script>\n")],-1),E=m('<div class="md-warning"><p><code>message</code> 属性虽然支持传入 HTML 片段，但是在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。因此在 <code>dangerouslyUseHTMLString</code> 打开的情况下，请确保 <code>message</code> 的内容是可信的，<strong>永远不要</strong>将用户提交的内容赋值给 <code>message</code> 属性。</p></div><h2 id="qu-fen-qu-xiao-yu-guan-bi"><a class="header-anchor" href="#qu-fen-qu-xiao-yu-guan-bi"></a> 区分取消与关闭</h2><p>有些场景下，点击取消按钮与点击关闭按钮有着不同的含义。</p>',3),z=r("div",null,[r("p",null,[g("默认情况下，当用户触发取消（点击取消按钮）和触发关闭（点击关闭按钮或遮罩层、按下 ESC 键）时，Promise 的 reject 回调和"),r("code",null,"callback"),g("回调的参数均为 'cancel'。如果将"),r("code",null,"distinguishCancelAndClose"),g("属性设置为 true，则上述两种行为的参数分别为 'cancel' 和 'close'。")])],-1),I=r("pre",null,[r("code",{class:"html"},"<template>\n  <hl-button type=\"link\" @click=\"open\">点击打开 Message Box</hl-button>\n</template>\n\n<script>\nimport { defineComponent, ref, h } from 'vue'\nimport { HlMessageBox, HlMessage } from 'hongluan-ui'\nexport default defineComponent({\n  setup() {\n    const open = () => {\n      HlMessageBox.confirm(\n        '检测到未保存的内容，是否在离开页面前保存修改？',\n        '确认信息',\n        {\n          distinguishCancelAndClose: true,\n          confirmButtonText: '保存',\n          cancelButtonText: '放弃修改',\n        },\n      )\n        .then(() => {\n          HlMessage({\n            type: 'info',\n            message: '保存修改',\n          })\n        })\n        .catch(action => {\n          HlMessage({\n            type: 'info',\n            message:\n              action === 'cancel' ? '放弃保存并离开页面' : '停留在当前页面',\n          })\n        })\n    }\n    return {\n      open,\n    }\n  }\n})\n<\/script>\n")],-1),U=m('<h2 id="quan-ju-fang-fa"><a class="header-anchor" href="#quan-ju-fang-fa"></a> 全局方法</h2><p>如果你完整引入了 Hongluan，它会为 <code>app.config.globalProperties</code> 添加如下全局方法：$msgbox, $alert, $confirm 和 $prompt。因此在 Vue instance 中可以采用本页面中的方式调用 <code>MessageBox</code>。调用参数为：</p><ul><li><code>$msgbox(options)</code></li><li><code>$alert(message, title, options)</code> 或 <code>$alert(message, options)</code></li><li><code>$confirm(message, title, options)</code> 或 <code>$confirm(message, options)</code></li></ul><h2 id="dan-du-yin-yong"><a class="header-anchor" href="#dan-du-yin-yong"></a> 单独引用</h2><p>如果单独引入 <code>MessageBox</code>：</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { HlMessageBox } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;hongluan-ui&#39;</span>\n</code></pre><p>那么对应于上述三个全局方法的调用方法依次为：HlMessageBox, HlMessageBox.alert, HlMessageBox.confirm，调用参数与全局方法相同。</p><h2 id="attributes"><a class="header-anchor" href="#attributes"></a> Attributes</h2><table><thead><tr><th>参数</th><th>说明</th><th>类型</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>title</td><td>MessageBox 标题</td><td>string</td><td>—</td><td>—</td></tr><tr><td>message</td><td>MessageBox 消息正文内容</td><td>string / VNode</td><td>—</td><td>—</td></tr><tr><td>dangerouslyUseHTMLString</td><td>是否将 message 属性作为 HTML 片段处理</td><td>boolean</td><td>—</td><td>false</td></tr><tr><td>type</td><td>类型</td><td>string</td><td>success / info / error / warning</td><td>—</td></tr><tr><td>customStyle</td><td>MessageBox 的自定义样式</td><td>object</td><td>—</td><td>{}</td></tr><tr><td>customClass</td><td>MessageBox 的自定义类名</td><td>string</td><td>—</td><td>—</td></tr><tr><td>callback</td><td>若不使用 Promise，可以使用此参数指定 MessageBox 关闭后的回调</td><td>function(action, instance)，action 的值为&#39;confirm&#39;, &#39;cancel&#39;或&#39;close&#39;, instance 为 MessageBox 实例，可以通过它访问实例上的属性和方法</td><td>—</td><td>—</td></tr><tr><td>showClose</td><td>MessageBox 是否显示右上角关闭按钮</td><td>boolean</td><td>—</td><td>true</td></tr><tr><td>beforeClose</td><td>MessageBox 关闭前的回调，会暂停实例的关闭</td><td>function(action, instance, done)，action 的值为&#39;confirm&#39;, &#39;cancel&#39;或&#39;close&#39;；instance 为 MessageBox 实例，可以通过它访问实例上的属性和方法；done 用于关闭 MessageBox 实例</td><td>—</td><td>—</td></tr><tr><td>distinguishCancelAndClose</td><td>是否将取消（点击取消按钮）与关闭（点击关闭按钮或遮罩层、按下 ESC 键）进行区分</td><td>boolean</td><td>—</td><td>false</td></tr><tr><td>lockScroll</td><td>是否在 MessageBox 出现时将 body 滚动锁定</td><td>boolean</td><td>—</td><td>true</td></tr><tr><td>showCancelButton</td><td>是否显示取消按钮</td><td>boolean</td><td>—</td><td>false（以 confirm 和 prompt 方式调用时为 true）</td></tr><tr><td>showConfirmButton</td><td>是否显示确定按钮</td><td>boolean</td><td>—</td><td>true</td></tr><tr><td>cancelButtonText</td><td>取消按钮的文本内容</td><td>string</td><td>—</td><td>取消</td></tr><tr><td>confirmButtonText</td><td>确定按钮的文本内容</td><td>string</td><td>—</td><td>确定</td></tr><tr><td>cancelButtonType</td><td>取消按钮的类型，参考 Button 文档</td><td>string</td><td>—</td><td>-</td></tr><tr><td>confirmButtonType</td><td>确定按钮的类型，参考 Button 文档</td><td>string</td><td>—</td><td>primary</td></tr><tr><td>cancelButtonClass</td><td>取消按钮的自定义类名</td><td>string</td><td>—</td><td>—</td></tr><tr><td>confirmButtonClass</td><td>确定按钮的自定义类名</td><td>string</td><td>—</td><td>—</td></tr><tr><td>closeOnClickModal</td><td>是否可通过点击遮罩关闭 MessageBox</td><td>boolean</td><td>—</td><td>true（以 alert 方式调用时为 false）</td></tr><tr><td>closeOnPressEscape</td><td>是否可通过按下 ESC 键关闭 MessageBox</td><td>boolean</td><td>—</td><td>true（以 alert 方式调用时为 false）</td></tr><tr><td>closeOnHashChange</td><td>是否在 hashchange 时关闭 MessageBox</td><td>boolean</td><td>—</td><td>true</td></tr><tr><td>roundButton</td><td>是否使用圆角按钮</td><td>boolean</td><td>—</td><td>false</td></tr><tr><td>buttonSize</td><td>自定义确认按钮及取消按钮的大小，参见 Button 文档</td><td>string</td><td>md</td><td></td></tr><tr><td>animationName</td><td>动画类型，参考内置过度动画文档</td><td>string</td><td>slideTop</td><td></td></tr><tr><td>icon</td><td>自定义icon，优先级高于type定义的icon</td><td>VNode</td><td>—</td><td>—</td></tr></tbody></table>',9);var D=h(B,[["render",function(t,e,n,o,d,s){const p=l("hl-demo0"),g=l("demo-block"),m=l("hl-demo1"),h=l("hl-demo2"),f=l("hl-demo3"),x=l("hl-demo4"),B=l("right-nav");return a(),c("section",M,[r("div",y,[C,b,H,T,k,i(g,null,{source:u((()=>[i(p)])),highlight:u((()=>[w])),default:u((()=>[v])),_:1}),j,L,i(g,null,{source:u((()=>[i(m)])),highlight:u((()=>[$])),default:u((()=>[S])),_:1}),V,N,i(g,null,{source:u((()=>[i(h)])),highlight:u((()=>[P])),default:u((()=>[_])),_:1}),O,i(g,null,{source:u((()=>[i(f)])),highlight:u((()=>[A])),default:u((()=>[q])),_:1}),E,i(g,null,{source:u((()=>[i(x)])),highlight:u((()=>[I])),default:u((()=>[z])),_:1}),U]),i(B)])}]]);export{D as default};
